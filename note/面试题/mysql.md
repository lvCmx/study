## MySQL常见面试题

**<a href="#1">1.有关事务的面试题</a>**  
&nbsp;&nbsp; <a href="#11">(1) 事务的特性</a>  
&nbsp;&nbsp; <a href="#12">(2) 并发操作问题</a>  
&nbsp;&nbsp; <a href="#13">(3) 事务的隔离级别</a>    
**<a href="#2">2.数据库索引</a>**  
&nbsp;&nbsp; <a href="#21">(1) 索引的种类</a>    
&nbsp;&nbsp; <a href="#22">(2) B+Tree索引</a>    
&nbsp;&nbsp; <a href="#23">(3) InnoDB索引实现</a>    
&nbsp;&nbsp; <a href="#24">(4) MyISAM索引实现</a>    
&nbsp;&nbsp; <a href="#25">(5) InnoDB与MyISAM在B+Tree索引的区别</a>     
&nbsp;&nbsp; <a href="#26">(6) 为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？</a>     
&nbsp;&nbsp; <a href="#27">(7) 聚集索引与非聚集索引</a>      
**<a href="#3">3.Mysql存储引擎</a>**    
&nbsp;&nbsp; <a href="#31">(1) InnoDB存储引擎：Mysql的默认事务型引擎</a>  
&nbsp;&nbsp; <a href="#32">(2) MyISAM</a>   
&nbsp;&nbsp; <a href="#33">(3) MEMORY</a>    
&nbsp;&nbsp; <a href="#34">(4) InnoDB与MyISAM区别</a>   
**<a href="#4">4.联合索引</a>**  
&nbsp;&nbsp; <a href="#41">(1) 联合索引的规则</a>  
&nbsp;&nbsp; <a href="#42">(2) 查辅助索引时需要查几次索引</a>   
**<a href="#5">5.Mysql读写分离</a>**    
&nbsp;&nbsp; <a href="#51">(1) 应用场景</a>  
&nbsp;&nbsp; <a href="#52">(2) 原理分析</a>  
&nbsp;&nbsp; <a href="#53">(3) 延迟问题解决方案</a>    
**<a href="#6">6.Mysql分库分表</a>**  
&nbsp;&nbsp; <a href="#61">(1) 为什么分库分表</a>  
&nbsp;&nbsp; <a href="#62">(2) 分库分表中间件</a>  
&nbsp;&nbsp; <a href="#63">(3) 垂直拆分与水平拆分</a>  


### <a name="1">1.有关事务的面试题</a>

**<a name="11"> (1) 事务的特性</a>**

- 原子性：是指事务包含所有操作要么全部成功，要么全部失败回滚。
- 一致性：指事务必须使数据库从一个一致性状态变换成另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。  
  拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
- 隔离性：是当多个用户并发访问数据库时，比如操作同一张表时，数据表为每个用户开启的事务，不能被其他事务所干扰，多个并发事务之间要相互隔离。
- 持久性：持久性是指一个事务一旦被提交，那么对数据库中的数据的改变就是永久的，即便是在数据库系统遇到故障的性况下也不会丢失提交事务的操作。

**<a name="12">(2) 并发操作问题</a>**

- 脏读：脏读是指在一个事务处理过程中读取到了另外一个未提交事务中的数据。
- 不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
- 虚读(幻读)：幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。  
  比如两个事务操作，A事务查询状态为1的记录时，这时B事务插入了一条状态为1的记录，A事务再次查询返回的结果不一样。

**<a name="13">(3) 事务的隔离级别</a>**

- Serializable(串行化)：可避免脏读、不可重复读、幻读。（就是串行化读数据）
- Repeatable read(可重复读)：可避免脏读、不可重复读的发生。
- Read committed(读已提交)：可避免脏读的发生。
- Read uncommitted(读未提交)：最低级别，任何情况都无法保证。

　　在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。

### <a name="2">2.数据库索引</a>

索引是表的目录，在查找内容之前可以先在目录中查找索引位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。  
索引是数据库中专门用于帮助用户快速查询数据的一种数据结构，类似于字典中的目录，查找字典内容时可以根据目录查找到数据的存放位置，然后直接获取即可。

- 索引由数据库中一列或多列组合而成，其作用是提高对表中数据的查询速度。
- 索引的优点是可以提高检索数据的速度。
- 索引的缺点是创建和维护索引需要耗费时间。
- 索引可以提高查询速度，会减慢写入速度。 

索引本身也很大，不可能全部存储在内存中，因此索引往往索引文件的形式存储在磁盘上。索引查找过程中就要产生磁盘IO消耗，相对于内存存取，IO存取的消耗要高几个数量级。所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。（换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。）

**<a name="21">(1) 索引的种类</a>**

​    B-tree、Hash、R-Tree、全文索引、主键索引、普通索引等。在mysql中索引是在存储引擎层而不是服务器层实现的，所以没有统一的索引标准。

- 普通索引：仅加速查询
- 唯一索引：加速查询+列值唯一。（可以有null）
- 主键索引：加速查询+列值唯一+表中只有一个（不可以有null）
- 组合索引：多列值组成一个索引。专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。

***B-Tree索引：***

​	B-Tree不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少，指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘IO次数，进而影响查询效率。

​	在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只能存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

​	数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。

 ***hash索引***

在进行查询操作时，使用hash索引效率很高。因此，当使用一个语句去比较字符中，然后返回结果集。这样的操作使用hash索引是很快的。

在字符串上创建Hash索引非常好，列值将插入到Hash表中和一个键对应，并和实际的数据行有一个映射关系，也就是该键是一个指向表中数据行的指针。Hash表实际是基于关联数组，假如有一个这样的语句：“boyce = 0×28936”其中0×28936是关联到存储在内存中的boyce。在hash表索引中查找boyce的值并返回内存中的数据，要比检索整个表的列值要快得多。

Hash表不能进行排序的数据结构，Hash表擅长的是键值对，也就是说，检索语句检查相等性。在Hash表中键值是没有排序的，在存储的时候也没有任何的排序规则。因为hash索引不够灵活，所以，hash索引不是默认的索引的数据结构。

- 不是按照索引顺序存储，不能用于排序。
- 不支持部分索引列匹配查找。
- 支持等值查询，不支持范围查询。
- 哈希值冲突多时，不适用。

 ***全文索引***

​    全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文索引和其他几种索引的匹配方式完全不一样，它更类似于搜索引擎做的事情，而不是简单的where条件匹配。可以在相同的列上，同时创建全文索引和B-Tree索引，全文索引适用于 Match Against 操作，而不是普通的where条件操作。

​    索引可以包含一个列（即字段）或多个列的值。如果索引包含多个列，一般会将其称作复合索引，此时，列的顺序就十分重要，因为MySQL只能高效的使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。

 **<a name="22">(2) B+Tree索引</a>**

 	在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

- B+Tree它的非叶子节点不存储数据，只存储索引，而数据会存放在叶子节点中。
- B+Tree规定：所有的叶子结点包含了全部关键字信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

在InnoDB存储引擎中，数据存放的方式是以页的方式进行存放，计算机在存储数据的时候，有最小存储单元，就是最小数据扇区，一个扇区的大小是512字节，而文件系统(ext4)他的最小单元是块，一个块的大小是4k，而对于我们的InnoDB存储引擎也有自己的最小存储单元--页。一个页的大小是16K。在InnoDB中默认的数据页的大小是16K。

数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一个数据的大小是1K,那么一个页可以存放16行这样的数据。

- InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，***在B+树中叶子节点存放数据，非叶子节点存放键值+指针***。
- 索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进页在云数据页中查找到需要的数据。

例如：  
假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。  
假设一行数据大小为：1KB,那么一页(16KB)中可以存放16行数据。  
假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14个字节。(8+6的意思是B+Tree有key和指针)  
            16KB * 1024(化成字节) / 14 =1170(一个节点可以存放页的指针数据)   
那么可以算出一棵高度为2的B+树，能存放1170*16=18720行  **解释：1170表示一个节点能够创建的指针数，而16表示，一个存放数据的页可以存放16行数据。***  
3阶B+树可以存放1170*1170*16=2千万（左右）  
所在在InnoDb中B+树高度一般为1-3层，它就能满足千万级的数据存储，在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。

在没有加数据记录大小的情况下：  
InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

**<a name="23">(3) InnoDB索引实现</a>**

InnoDB的数据文件本身就是索引文件，InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录，这个索引的key是数据表的主键。InnoDB表都必须有主键，如果没有定义主键，会默认添加一个主键。

一级索引（主键）：

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/Innodb_primarykey.png)

-  如果一个主键被定义了，那么这个主键就是作为聚焦索引。
- 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚焦索引。
- 如果没有主键也没有合适的唯一索引，那么InnoDB内部会生成一个隐藏的主键作为聚焦索引，这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增。

二级索引：

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/Innodb_secondary_key.png)

- 以所在的列建立二级索引，然后二级索引的data域则为主键。

**<a name="24">(4) MyISAM索引实现</a>**

MyISAM索引文件和数据文件是分离的，索引文件仅保存记录所在页的指针，通过这些地址来读取页，进而读取被索引的行。

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/myisam_primary_key.png)

**<a name="25">(5) InnoDB与MyISAM在B+Tree索引的区别</a>**

第一重大的区别是InnoDB的数据文件本身就是索引文件，MyISAM索引文件和数据文件是分离的，索引文件仅仅保存数据记录的地址，而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构。这棵树的叶节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）如果没有显示指定，则MySQL系统会自动选择一个可以唯一标识数据的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

第二个与MyISAM索引的不同是InnoDB的辅助索引DATA域存储相应记录主键的值而不是地址，InnoDB的所有辅助索引都引用主键作为data域。

***聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。***

**<a name="26">(6) 有一道MySQL的面试题，为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？</a>**

因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；红黑树BST的时间复杂度是依赖于树的高度，但是，红黑树的高度与Btree相比，高度更大。

**<a name="27">(7) 聚集索引与非聚集索引</a>**

聚集索引：也叫聚簇索引，聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值索引，其余就连续性记录在物理也一样连续存放，聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候会对数据页重新排序(InnoDB的B+树)。

非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+Tree结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式，非聚集索引层次多，不会造成数据重排。

### <a name="3">3.Mysql存储引擎</a>

在Mysql将每个数据库(Schema)保存为数据目录下的一个子目录。创建表时，Mysql会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。

有关：show table status like 'user'查看user表的相关信息：

**<a name="31">(1) InnoDB存储引擎：Mysql的默认事务型引擎</a>**

InnoDB使用的是行级锁，但实际是有限制的，只有在你增删改查时匹配的条件字段带有索引时，InnoDB才会使用行级锁，在你增删改查时匹配的条件字段不带有索引时。InnoDB使用的将是表级锁。

InnoDB是新版本mysql的默认引擎，支持事务处理和外键，但是其缺点就是慢了些，存储方式分为两种

1、共享表空间存储。这种方式创建的表的表结构保存在.frm 文件中，数据和索引保存在innodb_data_home_dir 和innodb_data_file_path 定义的表空间中，可以是多个文件。

2、多表空间存储。(.frm表结构和idb数据。) 这种方式创建的表的表结构仍然保存在.frm 文件中，但是每个表的数据和索引单独保存在.ibd 中。如果是个分区表，则每个分区对应单独的.ibd文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的IO 均匀分布在多个磁盘上。

使用engine=innodb default charset=utf-8;

**<a name="32">(2) MyISAM</a>**

MyISAM存储引擎是旧版本mysql的默认引擎，现在默认引擎是InnoDB，MyISAM引擎的主要特点就是快，没有事务处理操作，也不支持外键操作。适合insert与select的操作表。MyISAM存储引擎的表在数据库中，每一个表都被存放为三个以表名命名的物理文件。定义表结构.frm，存放表数据.myd和索引数据.myi。使用方法：engine=myisam default charset=utf-8;

其中MyISAM支持以下三种类型的索引;

- B-Tree索引，就是所有的索引节点都按照B-Tree的数据结构来存储，所有的索引数据节点都在叶节点。
- R-Tree索引
- Full-Text索引,全文索引，它的存储结构也是B-Tree。主要是为了解决在我们需要用like查询的低效问题。

**<a name="33">(3) MEMORY</a>**

存储引擎使用存在内存中的内容来创建表，每个Memory表只实现对应一个磁盘文件，格式是.frm(只保存表结构，不保存内容)。Memory类型的表访问非常快，因为它的数据是放在内存中的，并且默认使用Hash索引，但是一旦服务关闭，表中的数据就会丢失掉。

CREATE TABLE tab_memory ENGINE=MEMORY

给Memory表创建索引的时候，可以指定使用Hash索引还是BTree索引。

Create index mem_hash using HASH on table_memory(city_id);

**<a name="34">(4) InnoDB与MyISAM区别</a>**

 InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，MyISAM不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的强调的是性能。其执行速度比InnoDB类型更快，但是不提供事务类型支持。而InnoDB提供事务支持和外键。

### <a name="4">4.联合索引</a>

把联合索引单独拿出来是因为去滴滴面试的时候被问到过。

**<a name="41">(1) 联合索引的规则</a>**

联合索引可以将多个字段组合创建一个索引，在查询where条件中使用组合索引时，它符合最左匹配规则。例如为A,B,C三列创建索引，则它支持A/A,B/A,B,C而B,C则无法使用组合索引。

当一个列存在联合索引和单列索引时，mysql会根据查询语句的成本来选择走哪条索引。

**<a name="42">(2) 查辅助索引时需要查几次索引</a>**

需要两次：在前面的索引一节我们详细的介绍过辅助索引的结构，辅助索引的B+Tree结点的叶子结点存放的是一级索引的值，所以查到一级索引时，它会再查询一次一级索引。

### <a name="5">5.Mysql读写分离</a>

**<a name="51">(1) 应用场景</a>**

读写分离主要解决的是数据库的写操作是比较耗时的，而数据库的读取则是非常快的，所以读写分离来解决*数据库的写入，影响了查询的效率。*

***读写分离的好处***  
1) 分摊服务器压力，提高机器的系统处理效率。读写分离适用于读远比写的场景，如果有一台服务器，当select很多时，update和delete会被这些select访问中的数据堵塞，等待select结束，并发性能并不高，而主从只负责各自的写和读，极大程度的缓解X锁和S锁争用；  
2) 增加冗余，提高服务可用性，当一台数据库服务器宕机后可以调整另外一台从库以最快速度恢复服务

**<a name="52">(2) 原理分析</a>**

主库将插入、更新或删除的记录写入到了binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个SQL线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。  
![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/mysql_separate.png)

这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。

***mysql半同步复制：***

这个所谓半同步复制，semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。

***并行复制***

所谓并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。

**<a name="53">(3) 延迟问题解决方案</a>**

在Master上增加一个自增表，这个表仅含有1个字段，当master接收到任何数据更新的请求时，均会触发这个触发器，该触发器更新自增表中的记录。

MySQL_Poxy解决方案：

***写数据时：***由于Count_table也参与Mysq的主从同步，因此在Master上作的 Update更新也会同步到Slave上。当Client通过Proxy进行数据读取时，Proxy可以先向Master和Slave的 Count_table表发送查询请求，当二者的数据相同时，Proxy可以认定 Master和Slave的数据状态是一致的，然后把select请求发送到Slave服务器上，否则就发送到Master上。如下图所示： 

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/mysql_poxy_write.png)

***读数据时：***通过这种方式，就可以比较完美的结果MySQL的同步延迟不可控问题。之所以所“比较完美”，是因为这种方案double了查询请求，对Master和Slave构成了额外的压力。不过由于Proxy与真实的Mysql Server采用连接池的方式连接，因此额外的压力还是可以接受的

>>>>>>> ### <a name="6">6.Mysql分库分表</a>
>>>>>>>
>>>>>>> **<a name="61">(1) 为什么分库分表</a>**
>>>>>>>
>>>>>>> ![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/partition_table.png)
>>>>>>>
>>>>>>> ​	比如一个项目单表都几千万数据了，mysql数据库已经抗不住了，单表数据量太大，会极大影响你的sql执行的性能，会发遭受sql可能就跑的越来越慢。  
>>>>>>> ​	分表就是把一个表的数据放到多个表中，然后项目查询数据的时候只查询一个表，比如按照用户id来分表，将一个用户的数据就放在一个用中。这样可以控制每个表的数据量在可控的范围内，比如每个表固定在200万以内。  
>>>>>>> ​	分库就是你一个库最多支撑并发2000，而且一个健康的单库并发值你最好保持在每秒1000左右，不要太大，那么你可以将一个库的数据拆分到多个库中，访问的时候访问一个库就好了。
>>>>>>>
>>>>>>> **<a name="62">(2) 分库分表中间件</a>**

数据库分库/分表中间件有两类：一类是client层，也就是直接在系统中使用的，另一类是proxy层，需要单独部署这种中间件。

- sharding-jdbc这种client层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合sharding-jdbc的依赖；
- mycat这种proxy层方案的缺点在于需要部署，自己及运维一套中间件，运维成本高，但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。

**<a name="63">(3) 垂直拆分与水平拆分</a>**

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/水平与垂直拆分.png)

​	***水平拆分：***就是把一个表的数据给拆分到多个库的多个表里面去，但是每个库的表结构都一样，只不过每个库下表放的数据是不同的，所有的不同库的表数据加起来就是全部数据，水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。  
​	***垂直拆分：***就是把一个有很多字段的表给拆分成多个表，或者是多个库上去，每个库表的结构都不一样，每个库都都包含部分字段。一般来说会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。

​	你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都ok了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。  
​	而且这儿还有两种分库分表的方式，一种是按照range来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了；或者是按照某个字段hash一下均匀分散，这个较为常用。  
​	range来分，好处在于说，后面扩容的时候，就很容易，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用range，要看场景，你的用户不是仅仅访问最新的数据，而是均匀的访问现在的数据以及历史的数据  
​	hash分法，好处在于说，可以平均分配没给库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的这么一个过程。