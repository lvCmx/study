## 1.如何进行消息队列的技术选型

### 解耦

**不用MQ的系统耦合场景**

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/不用mq的系统.png)

说明：A系统发送数据到BCDEF各个系统中，接口调用发送，那么此时，如果出现一个系统G也需要这个数据呢？那如果D系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统负责人估计已经崩溃了。另外A系统时时刻刻考虑BCDEF系统如果挂了怎么办？要不要重新发送数据等问题。

**使用mq的系统**

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/mq系统.png)

你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给他异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个MQ去进行系统的解耦。在简历中体现出来这块东西，用MQ作解耦。

### 异步

**不使用mq的系统**

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/异步-不用mq.png)

A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms、450ms、200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近1s，用户感觉搞个什么东西，慢死了慢死了。

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/mq中的异步系统.png)

### 削峰

**没有mq削值把mysql压崩**

![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/削峰-mq01.png)

例如：我们现在有这样一个需要，系统中午的时候，访问的用户比较多，当每秒要操作2000条以上的sql语句时，mysql可能支撑不住，会把数据压跨。

**用mq削峰**

<<<<<<< HEAD
![](F:\__study__\hulianwang\study\note\面试题\resource\mq削峰.png)
=======
![](https://github.com/lvCmx/study/blob/master/note/面试题/resource/削峰-mq01.png)
>>>>>>> 5db082fe5b142d91d20721717a8364b06e15760f

## 2.消息队列有什么优点和缺点啊?

优点就是上面所说的三点：解耦、异步、削峰

缺点：

- 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。
- 系统复杂性提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已
- 一致性问题：A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。

### 3.常用的MQ的对比？



### 4.如何保证消息队列的高可用啊？

#### RabbitMQ保证高可用

**三种模式**

- 单一模式：即单机情况不做集群，就单独运行一个rabbitMQ而已。

- 集群模式：

  ![](F:\__study__\hulianwang\study\note\面试题\resource\mq集群模式.png)

  以两台机器(A/B)为例来进行说明，对于Queue来说，消息实体只存在于其中一个节点，而A或B两个节点仅有相同的元烽据，即队列的结构。当消息进入A节点的Queue后，consumer从B节点消费时，RabbitMQ会面临在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer,所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理 Queue。否则无论consumer连A/B，出口总在A，会产生瓶颈。当A节点出现故障后，B节点无法取到A节点中还未消费的消息实体。如果做了消息持久化，那么得A节点恢复，然后才可被消费。如果没有持久化的话，就会产生消息丢失的现象。

- 镜像模式：

  ![](F:\__study__\hulianwang\study\note\面试题\resource\镜像模型.png)

  这种模式才是所谓的rabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息同步到多个实例的queue里进行消息同步。这样的话，当一台机器宕机了，别的机器都可以用。坏外在于，性能开销太大。另外如果某个queue负载很重，你加机器 ，新增的机器也包含了这个queue的所有的数据，并没有办法扩展你的queue。

**客户端连接RabbitMQ集群策略**



#### Kafka高可用

![](F:\__study__\hulianwang\study\note\面试题\resource\kafka高可用.png)

kafka0.8以后，提供了HA机制，就是replica(复制品)副本机制，每个partition的数据都会同步到其它机器上，形成自己的多个replica副本。所有replica会选举一个leader出来，那么生产和消费都跟这个leader打交道，然后其他replica就是follower。写的时候leader会负责把数据同步到所有follower上去，读的时候就直接读leader上的数据即可。只能从leader操作，原因是保证数据一致性问题。

**可靠性是如何保证的？**

1、数据的副本

2、如果leader宕机了，那么此时会从follower中重新选举一个新的leader出来。大家继续读写那个新的leader即可。

3、写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己主动从leader来pull数据。一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有follower的ack之后，就会crcp回写成功的消息给生产者。

### 5.如何保证消息不被重复消费啊（如何保证消息消费时的幂等性）？

有时候无法保证MQ只发一次消息，所以，做预防的时候，需要我们自己根据自己的实际业务来处理。

以kafka为例讲解此问题。

**如何保证消息不被重复消费啊？**

kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次我要是重启服务的话，你就让我接着从上次消费到的offset来继续消费。其中这个offset保存在zookeeper中。

另外如果在重启服务的时候，直接kill进程了，再重启。这会导致consumer有些消息处理了，但是没有来得及提交offset，重启之后，少数消息会再次消费一次。

给你举个例子吧。假设你有个系统，消费一条往数据库里插入一条，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下已经消费过了，直接扔了，不就保留了一条数据？

一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性

 **如何保证消息消费时的幂等性？**

幂等性，我通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。

其实还是得结合业务来思考，我这里给几个思路：

（1）比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下好吧

（2）比如你是写redis，那没问题了，反正每次都是set，天然幂等性

（3）比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。

还有比如基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据

如何保证MQ的消费是幂等性的，需要结合具体的业务来看

### 6.如何保证消息的可靠性传输（如何处理消息丢失的问题）？

