**1.final关键字**

- 当用final去修饰一个类的时候，表示这个类不能被继承（final类下的方法也是final的）
- final修饰的方法不能被重写，一个类的private方法会隐式的被指定为final方法。
- final修饰的成员变量要么直接赋值或在构造函数中赋值。

**2.默认方法**

java接口中可以定义默认方法，如果A，B两个接口都有相同名称的默认方法，那么在C接口继承A,B之后，需要重写这个默认方法。

**3.类的加载顺序**

- 父类静态变量
- 父类静态代码块
- 子类静态变量
- 子类静态代码块
- 父类普通变量
- 父类普通代码块
- 父类构造函数
- 子类普通变量
- 子类普通代码块
- 子类构造函数

**4.ArrayList**

初始大小10，扩容1.5倍，线程不安全

**5.HashMap**

默认大小16，扩容2倍，单个链表长度达到8转红黑树，少于6转链表。或者是总体链表结点个数达64转红黑树。

**6.Object中的方法**

wait/notify/notifyAll/hashCode/clone/toString/equals

**7.sleep与sleep(0)**

sleep方法被调用时，它不会释放占有的资源。sleep时间过后，不一定立即会得到执行，因为睡眠时间到达后，有可能另外一个线程正在使用CPU，或者是有优先级高的线程正在使用CPU。

sleep(0)的作用是：触发操作系统立刻重新进行一次CPU竞争，竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。

**8.sleep与wait**

sleep：

- 让当前线程休眠指定时间
- 休眠时间的准确性依赖于系统时钟和CPU调用机制
- 不释放已获取的锁资源
- 可以通过调用interrupt()方法来唤醒休眠线程

wait：

- 让当前线程进入等待状态，当别的其他线程调用notify或者notifyAll方法时，当前线程进入就绪状态
- wait方法必须在同步上下文中调用，例如：同步方法块或者同步方法中，这也就意味着如果你想要调用wait方法，提前是必须获取对象上的锁资源。
- 当wait方法调用时，当前线程将会释放已获取的对象锁资源，并进入等待队列，其他线程就可以尝试获取对象上的锁资源。

**9.ThreadLocal**

Thread类中有一个threadLocals，其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面。也就是说，ThreadLocal类型的本地变量存放在具体的线程内存空间中。将当前线程以key存放在threadLocals中。使用完毕后需要调用ThreadLocal变量的remove方法，从当前线程的threadLocals里面删除本地变量。

**10.servlet是单例的并且是线程不安全的**

要解释为什么Servlet为什么不是线程安全的，需要了解Servlet容器（即Tomcat）是如何响应HTTP请求的。

当Tomcat接收到Client的HTTP请求时，Tomcat从线程池中取出一个线程，之后找到该请求对应的Servlet对象并进行初始化，之后调用service()方法。要注意的是每一个Servlet对象再Tomcat容器中只有一个实例对象，即是单例模式。如果多个HTTP请求请求的是同一个Servlet，那么着两个HTTP请求对应的线程将并发调用Servlet的service()方法。

**乐观锁与悲观锁**

悲观锁：指对数据被外界修改保持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。

乐观锁：是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。

**公平锁与非公平锁**

根据线程获取锁的抢占机制，锁可以分为公平锁与非公平锁。公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。而非公平锁则在运行时闯入，也就是先来不一定先得。

ReetrantLock提供了公平与非公平锁的实现：

- 公平锁：new ReetrantLock(true)
- 非公平锁：new ReetrantLock(false) 默认是非公平锁。

synchronized是非公平锁

**独占锁与共享锁**

根据锁只能被单个线程持有还是被多个线程共同持有，锁可以分为独占锁和共享锁。

独占锁保证任何时间都只有一个线程能得到锁，ReetrantLock就是以独占方式实现的。共享锁则可以同时由多个线程持有，例如：ReadWriteLock读写锁，它允许一个资源可以被多线程同时进行读操作。

独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性，而独占锁只允许同一时间由一个线程读取数据，其他线程必须等待当前线程释放才能进行读取。

**可重入锁**

synchronized内部锁是可重入锁，可重入锁的原理是在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁时，计数器的值会变成1，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞扶起。

但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加+1，当释放锁后计数器值-1 。当计数器值为0时，锁里面的线程标示被重置为null，这时候被阻塞的线程会被唤醒来竞争获取该锁。

**自旋锁**

由于java中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁失败后，会被切换到内核状态而被挂起，当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取（默认次数是10，可以使用-XX:PreBlockSpinsh），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来自旋锁是使用CPU时间换取线程阻塞与调度的开销，但是很有可能这些CPU时间白白浪费了。

**死锁**

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力的作用的情况下，这些线程会一直相互等待而无法继续运行下去。

死锁产生的必要条件：

- 互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。
- 请求并保持条件：指一个线程已经至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。
- 不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。
- 循环等待：T0正在等待一个T1占有的资源，T1正在等待T2占用的资源，Tn正在等待T0占用的资源。

**volatile**

当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。

volatile虽然提供了可见性保证，但并不保证操作的原子性。如果依赖当前值，将是获取-计算-写入三步操作，这三步操作不是原子性的，而volatile不保证原子性。

**CAS**



