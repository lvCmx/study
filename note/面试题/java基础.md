**1.final关键字**

- 当用final去修饰一个类的时候，表示这个类不能被继承（final类下的方法也是final的）
- final修饰的方法不能被重写，一个类的private方法会隐式的被指定为final方法。
- final修饰的成员变量要么直接赋值或在构造函数中赋值。

**2.默认方法**

java接口中可以定义默认方法，如果A，B两个接口都有相同名称的默认方法，那么在C接口继承A,B之后，需要重写这个默认方法。

**3.类的加载顺序**

- 父类静态变量
- 父类静态代码块
- 子类静态变量
- 子类静态代码块
- 父类普通变量
- 父类普通代码块
- 父类构造函数
- 子类普通变量
- 子类普通代码块
- 子类构造函数

**4.ArrayList**

初始大小10，扩容1.5倍，线程不安全

**5.HashMap**

默认大小16，扩容2倍，单个链表长度达8转红黑树，少于6转链表。或者是总体链表结点个数达64转红黑树。

**6.Object中的方法**

wait/notify/notifyAll/hashCode/clone/toString/equals

**7.sleep与sleep(0)**

sleep方法被调用时，它不会释放占有的资源。sleep时间过后，不一定立即会得到执行，因为睡眠时间到达后，有可能另外一个线程正在使用CPU，或者是有优先级高的线程正在使用CPU。

sleep(0)的作用是：触发操作系统立刻重新进行一次CPU竞争，竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。

**8.sleep与wait**

sleep：

- 让当前线程休眠指定时间
- 休眠时间的准确性依赖于系统时钟和CPU调用机制
- 不释放已获取的锁资源
- 可以通过调用interrupt()方法来唤醒休眠线程

wait：

- 让当前线程进入等待状态，当别的其他线程调用notify或者notifyAll方法时，当前线程进入就绪状态
- wait方法必须在同步上下文中调用，例如：同步方法块或者同步方法中，这也就意味着如果你想要调用wait方法，提前是必须获取对象上的锁资源。
- 当wait方法调用时，当前线程将会释放已获取的对象锁资源，并进入等待队列，其他线程就可以尝试获取对象上的锁资源。

**9.ThreadLocal**

Thread类中有一个threadLocals，其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面。也就是说，ThreadLocal类型的本地变量存放在具体的线程内存空间中。将当前线程以key存放在threadLocals中。使用完毕后需要调用ThreadLocal变量的remove方法，从当前线程的threadLocals里面删除本地变量。

**10.servlet是单例的并且是线程不安全的**

要解释为什么Servlet为什么不是线程安全的，需要了解Servlet容器（即Tomcat）使如何响应HTTP请求的。

当Tomcat接收到Client的HTTP请求时，Tomcat从线程池中取出一个线程，之后找到该请求对应的Servlet对象并进行初始化，之后调用service()方法。要注意的是每一个Servlet对象再Tomcat容器中只有一个实例对象，即是单例模式。如果多个HTTP请求请求的是同一个Servlet，那么着两个HTTP请求对应的线程将并发调用Servlet的service()方法。

**乐观锁与悲观锁**

悲观锁：指对数据被外界修改保持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。

乐观锁：是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。

**公平锁与非公平锁**

根据线程获取锁的抢占机制，锁可以分为公平锁与非公平锁。公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。而非公平锁则在运行时闯入，也就是先来不一定先得。

ReetrantLock提供了公平与非公平锁的实现：

- 公平锁：new ReetrantLock(true)
- 非公平锁：new ReetrantLock(false) 默认是非公平锁。

**独占锁与共享锁**

根据锁只能被单个线程持有还是被多个线程共同持有，锁可以分为独占锁和共享锁。

独占锁保证任何时间都只有一个线程能得到锁，ReetrantLock就是以独占方式实现的。共享锁则可以同时由多个线程持有，例如：ReadWriteLock读写锁，它允许一个资源可以被多线程同时进行读操作。

独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性，而独占锁只允许同一时间由一个线程读取数据，其他线程必须等待当前线程释放才能进行读取。

**可重入锁**





**自旋锁**



