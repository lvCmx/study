

## <a name="2">2.Java内存区域与内存溢出异常</a>

### (1) 内存区域的划分

![](F:\__study__\hulianwang\study\note\java\jvm\img\jvm.png)

**程序计数器**

​	它是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。  
​	由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。

**虚拟机栈**

![](F:\__study__\hulianwang\study\note\java\jvm\img\jvm_stack.png)

​	虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  
​	在java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展(当前大部分的java虚拟机栈都可以动态扩展，只不过java虚拟机规范中也允许固定长度的虚拟机栈)，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

**本地方法栈**

​	本地方法栈与虚拟机栈所发挥的作用是非常相似的，本地方法栈则为虚拟机使用到的Native方法服务。

**java堆**



**方法区**



