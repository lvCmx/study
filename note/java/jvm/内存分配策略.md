## JVM内存分配策略

**<a href="#1">1.对象优先在Eden分配</a>**    
**<a href="#2">2.大对象直接进入老年代</a>**  
**<a href="#3">3.长期存活的对象将进入老年代</a>**  
**<a href="#4">4.动态对象年龄判定</a>**  
**<a href="5">5.空间分配担保</a>**

### <a name="1">1.对象优先在Eden分配</a>

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

例如：尝试分配3个2MB大小和1个4MB大小的对象，在运行时通过-Xmx20M、-Xmx20M、-Xmn10M这3个参数限制了Java堆大小为20MB，不可扩展。其中10MB给了新生代，剩下的10M分配给老年代。-XX:SurvivorRaito=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1。则新生代总共可用空间大概为9M(8M+1M,另外1M用于s1)

在Eden区分配对象时，如果Eden区没有足够的空间，并且触发的一次Minor GC Eden区空间任然不够使用时，则通过分配担保机制提前转移到老年代中去创建。

- [ ] 新生代（Minor GC）：指发生在新生代的垃圾收集动作。Minor GC非常频繁，一般回收速度也比较快。
- [ ] 老年代（Major GC）：指发生在老年代的GC，出现Major GC，经常会伴随至少一次的Minor GC。

### <a name="2">2.大对象直接进入老年代</a>

所谓大对象是指，需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。

虚拟机提供了一个-XX:PretenutreSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区经及两个Survivor区间发生大量的内存复制。

### <a name="3">3.长期存活的对象将进入老年代</a>

既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应该放在新生代，哪些对象放应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移除到Survivor空间中。并且对象年龄设为1。对象(默认15岁)，就将会被晋升到老年代中。对象晋代老年代的年龄总阈值，可以通过-XX:MaxTenuringThreshold设置。

### <a name="4">4.动态对象年龄判定</a>

为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor（Survivor指的是s0或者是s1）空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

例如：-Xmx20M、-Xmx20M、-Xmn10M -XX:MaxTenuringThreshold=15 -XX:SurvivorRaito=8

创建两个大小为265的对象，两个对象的总和大于Survivor空间的一半，此时，这两个对象将会被晋升到老年代中去。

### <a name="5">5.空间分配担保</a>

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间>新生代所有对象的总空间

- 如果大于，则此次**Minor GC是安全的**
- 如果小于，则虚拟机会查看**HandlePromotionFailure**设置值是否允许担保失败。
   如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于**历次晋升到老年代的对象的平均大小**，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。

上面提到了Minor GC依然会有风险，是因为新生代采用**复制收集算法**，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。**老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象**，但一共有多少对象在内存回收后存活下来是不可预知的，**因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考**。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。

取平均值仍然是一种**概率性的事件**，如果某次Minor GC后存活对象陡增，远高于平均值的话，必然导致担保失败，如果出现了分配担保失败，**就只能在失败后重新发起一次Full GC**。虽然存在发生这种情况的概率，但**大部分时候都是能够成功分配担保**的，这样就避免了过于频繁执行Full GC。

