
## <a name="2">Java内存区域详解</a>

### (1) 内存区域的划分

![](https://github.com/lvCmx/study/blob/master/note/java/jvm/img/jvm.png)

**程序计数器**

​	它是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。  
​	由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。

**虚拟机栈**

![](https://github.com/lvCmx/study/blob/master/note/java/jvm/img/jvm_stack.png)

​	虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  
​	在java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展(当前大部分的java虚拟机栈都可以动态扩展，只不过java虚拟机规范中也允许固定长度的虚拟机栈)，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

**本地方法栈**

​	本地方法栈与虚拟机栈所发挥的作用是非常相似的，本地方法栈则为虚拟机使用到的Native方法服务。

**java堆**

![](https://github.com/lvCmx/study/blob/master/note/java/jvm/img/jvm_heap.png)

​	堆是java虚拟机所管理的内存中最大的一块，java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。  
​	由于现在收集器基本都采用分代收集算法，所以java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快的分配内存。

**方法区**

​	方法区与堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在JDK1.6及之前方法区包含常量池。而JDK1.7及以后，JVM已经将运行时常量池从方法区中移了出来，在JVM堆开辟了一块区域存放常量池。  

**运行时常量池**

常量池用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

**元空间**

元空间是jdk1.8之后取消了永远代（方法区），改为元空间，类的元信息被存储在元空间中，元空间没有使用堆内存，而是使用与堆不相连的本地内存区域。理论上系统可以使用的内存有多大，元空间就有多大。

### (2) 内存溢出异常

**java堆溢出**

在对象数量到达最大堆得容量限制后就会产生内存溢出异常。

目的是确认内存中的对象是否是必要的（先分清楚是内存泄漏（Memory Leak）还是内存溢出（Memory Overflow））

1.内存泄漏（堆内存无法释放造成系统内存的浪费）：查看泄漏对象到GC Roots的引用链。就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的，就可以准备定位泄漏代码的位置

2.如果不存在泄漏,即所有对象都必须存活，检查虚拟机的堆参数（-Xmx与-Xms）与物理内存对比是否需要上调，从代码上检查是否存在某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗

**虚拟机栈和本地方法栈溢出**

HotSpot不分区虚拟机栈和本地方法栈，因此栈容量只由-Xss参数设定

1.StackOverflowError：如果线程请求的栈深度大于虚拟机所允许的最大深度（主）（阅读错误堆栈）

2.OutOfMemoryError：如果虚拟机在拓展栈时无法申请到足够的内存空间 

### (3) 内存参数

- -Xms：堆大小，默认为操作系统物理内存的1/64但小于1G。默认当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小。

- -Xmx：堆最大值，默认值为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小。

- -Xmn：年青代的大小，整个堆大小=年轻代大小+老年代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。

  ![](F:\__study__\hulianwang\study\note\java\jvm\img\堆空间比例.png)

- 程序新创建的对象都是从年轻代分配内存，年轻代由Eden Space和两块相同大小的SurvivorSpace(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定年轻代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及SurvivorSpace的大小。

- 老年代用于存放经过多次新生代GC仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：

  1. 大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。
  2. 大的数组对象，且数组中无引用外部对象。老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

**关于新生代与老年代的总结**

默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。

其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。

默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。

JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。