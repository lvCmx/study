## 线程池原理以及自定义线程池

##### 线程池原理

所谓线程池，就是里面存放着已经创建好的线程，当有任务提交给线程池执行时，池子中的某个线程会主动执行该任务。如果池子中的线程数量不够应付数量众多的任务时，则需要自动扩充新的线程到池子中，但是该数量是有限的。当任务比较少的时候，池子中的线程能够自动回收，释放资源，为了能够异步地提交任务和缓存未被处理的任务，需要有一个任务队列。

![](F:\__study__\hulianwang\study\note\java\java高并发编程详解\img\06_01_threadPoll.png)

通过上面的描述，一个完整的线程池应该具备如下要素：

- 任务队列：用于缓存提交的任务
- 线程数量管理功能：一个线程池必须能够很好的管理和控制线程数量，比如创建线程时初始的线程数量init；线程池自动扩充时最大的线程数量max，在线程池空闲时需要释放线程但是也要维护一定数量的活跃数量或者核心数量core。而三者的关系init<core<max
- 任务拒绝策略：如果线程数量已达到上限且任务队列满时，则需要有相应的拒绝策略来通知任务提交者。
- 线程工厂：主要用于个性化定制线程，比如线程设置为守护线程以及线程名称。
- QueueSize：任务队列主要存放提交的Runnable，但是为了防止内存溢出，需要有limit数量对其进行控制。
- Keepedalive时间：该时间主要决定线程各个重要参数自动维护的时间间隔。

##### 线程池实现

**线程池接口定义**

ThreadPool：

```java
public interface ThreadPool {
    // 提交任务到线程池
    void execute(Runnable runnable);

    // 关闭线程池
    void shutdown();

    // 获取线程池的初始化大小
    int getinitSize();

    // 获取线程池最大的线程数
    int getMaxSize();

    // 获取线程池的核心线程数量
    int getCoreSize();

    // 获取线程池中用于缓存任务队列的大小
    int getQueueSize();

    // 获取线程池中活跃线程的数量
    int getActiveCount();

    // 查看线程池是否已被shutdown
    boolean isShutdown();
}
```

RunnableQueue，主要用于存放提交的Runnable

```java
// 任务队列，主要用于缓存提交互线程池中的任务
public interface RunnableQueue {
    // 当有新的任务进来时首先会offer到队列中
    void offer(Runnable runnable);

    // 工作线程通过task方法获取Runnable
    Runnable take();

    // 获取任务队列中任务的数量
    int size();
}
```

ThreadFactory提供了创建线程的接口

DenyPolicy：

```java
// 拒绝策略
@FunctionalInterface
public interface DenyPolicy {
    void reject(Runnable runnable,ThreadPool threadPool);

    // 该拒绝策略会直接将任务丢弃
    class DiscardDenyPolicy implements DenyPolicy{
        @Override
        public void reject(Runnable runnable, ThreadPool threadPool) {
            // do nothing
        }
    }

    // 该拒绝策略会向任务提交者抛出异常
    class AbortDenyPolicy implements DenyPolicy{
        @Override
        public void reject(Runnable runnable, ThreadPool threadPool) {
            throw new RunnableDeyException("The runnable "+runnable+" will be abort.");
        }
    }

    // 该拒绝策略会使任务在提交者所在的线程中执行任务
    class RunnerDenyPolicy implements DenyPolicy{
        @Override
        public void reject(Runnable runnable, ThreadPool threadPool) {
            if(!threadPool.isShutdown()){
                runnable.run();
            }
        }
    }
}
```

RunnableDenyException：

```java
// 队列满的异常
public class RunnableDeyException extends RuntimeException{
    public RunnableDeyException(String message){
        super(message);
    }
}
```





##### 线程池的应用

