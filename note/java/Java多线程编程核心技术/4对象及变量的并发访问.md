## 对象及变量的并发访问

这节主要说的就是synchronized的基本使用与控制资源的访问

##### synchroized修饰方法

**方法内的变量为线程安全**

因为在方法内部的变量，无论有多少个线程调用这个方法，它都会重新创建这个变量，因为方法内的变量是局部变量，它只能在当前线程中访问的这个方法中使用。

例如：

```java
public class Demo {
    public void addI(String name) throws Exception{
        int number=0;
        System.out.println(name+":begin demo");
        if("a".equals(name)){
            number=100;
            Thread.sleep(2000);
            System.out.println("a set  over!");
        }else{
            number=200;
            System.out.println("b set  over!");
        }
        System.out.println(name +" is number =" +number);
    }
}
public class ThreadA extends Thread{
    private Demo demo;
    public ThreadA(Demo demo) {
        super();
        this.demo = demo;
    }
    public void run() {
        try {
            demo.addI("a");
        } catch (Exception e) {}
    }
}
public class ThreadB extends Thread{
    private Demo demo;
    public ThreadB(Demo demo) {
        super();
        this.demo = demo;
    }
    public void run(){
        try {
            demo.addI("b");
        } catch (Exception e) {}
    }
}
public class ThreadTest{
    public static void main(String[] args) {
        Demo demo = new Demo();
        ThreadA threadA = new ThreadA(demo);
        threadA.start();
        ThreadB threadB= new ThreadB(demo);
        threadB.start();
    }
}
```

运行结果:

a:begin demo

b:begin demo

b set  over!

b is number =200

a set  over!

a is number =100

**实例变量非线程安全**

如果并发类存在成员变量，并且在编程中使用到了成员变量，会产生并发问题

如果把上面的Demo中的int number=0改成全局变量,则运行的结果:

a:begin demo

b:begin demo

b set  over!

b is number =200

a set  over!

a is number =200

关于实例变量非线程安全的解决方法，就是在add方法的前面加上一个syncrhoized使当前方法变为同步的，就可以了。

修改后，运行结果如下:

b:begin demo

b set  over!

b is number =200

a:begin demo

a set  over!

a is number =100

 实验结论：在两个线程访问同一个对象中的同步方法时一定是线程安全的。

**多个对象多个锁**

修改如下代码:

将addI()修改为synchroinzed，但是要求add方法不能是静态的方法。

修改运行main：

b:begin demo

b set  over!

b is number =200

a:begin demo

a set  over!

a is number =100

从结果中我们可以看出，两个线程分别访问同一个类的两个不同实例的相同名称的同步方法，效果却是以异步的方式运行的。

**使用synchroized的注意事项**

关键字synchroinzed取得的锁都是对象锁，而不是把一段代码或方法当作锁，哪个线程先执行带有synchroized关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其它线程只能呈等待状态，前提是多个线程访问的是同一个对象。

另外，synchroinzed加在方法上，也表示的是this锁（对象锁），如果其它线程想访问这个类中的其它带有synchronized的方法，也是不能进行访问的。

出现异常的时候锁会自动释放

java类锁与对象锁：对象锁用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。

