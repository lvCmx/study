### 1.redis持久化的意义

redis持久化的意义在于故障恢复，比如部署了一个redis，作为cache缓存，如果没有持久化的话，redis遇到灾难性故障的时候就会丢失所有的数据。

如果通过持久化将数据搞一份在磁盘上，然后定期将备份上到云服务上去，那么就可以保证数据不丢失全部，还是可以恢复一部分数据。

### 2.RDB和AOF两种持久化机制介绍

前面介绍了如果redis出现宕机，而且没有数据恢复策略的话，很有可能会出现大量请求过来，缓存全部无法命中，直接将请求打到了mysql数据库中，很容易会将mysql服务压垮，我们称这种情况也是缓存雪崩问题。  

redis支持两种持久化机制，一种是RDB和AOF。

**(1)RDB和AOF两种持久化机制**

![](F:\__study__\hulianwang\study\note\项目\亿级流量电商详情-缓存架构师\img\RDB和AOF的介绍.png)

RDB持久化机制，是对redis中的数据执行周期性的持久化，每次会生成一个新的文件。

AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集。

如果只是想采用redis作为纯内存的缓存来用，那么可以禁止RDB和AOF所有的持久化机制。

通过RDB和AOF，都可以将redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到云服务中去。

**(2)RDB持久化机制**

优点：

- RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去。
- RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可。
- 相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程更加快速。

缺点：

- 因为RDB是基于周期性备份的，所以相对于AOF数据更完整一些。
- RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒

**(3)AOF持久化机制**

优点：

- AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次sync操作，将操作系统中缓存的数据刷新到磁盘上去。
- AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。
- AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。
- AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据

缺点：

- 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大
- AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件

**(4)RDB和AOF到底该如何选择**

- 不要仅仅使用RDB，因为那样会导致你丢失很多数据
- 也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug
- 综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。

### 3.RDB试验

**(1)开启RDB持久化机制**

在redis.conf配置文件中，默认是已经开启RDB持久化机制的：

save 60 1000：每隔60s，如果有超过1000个key发生了变更，那么就生成一个新的dump.rdb文件，就是当前redis内存中完整的数据快照，快照也可以手动调用save或者bgsave命令，同步或异步执行rdb快照生成。

save可以设置多个，就是多个snapshotting检查点，每到一个检查点，就会去check一下，是否有指定的key数量发生了变更，如果有，就生成一个新的dump.rdb文件

**(2)RDB持久化机制的工作流程**

（1）redis根据配置自己尝试去生成rdb快照文件
（2）fork一个子进程出来
（3）子进程尝试将数据dump到临时的rdb快照文件中
（4）完成rdb快照文件的生成之后，就替换之前的旧的快照文件

dump.rdb，每次生成一个新的快照，都会覆盖之前的老快照

### 4.AOF试验

**(1)AOF持久化的配置**

AOF持久化，默认是关闭的，默认是打开RDB持久化。

开启AOF：打开配置文件redis.conf，【appendonly yes】可以打开AOF持久化机制，生产环境里面一般要求打开RDB和AOF两种持久化，除非是允许丢失几分钟的数据才关闭AOF

- 打开AOF持久化机制之后，redis每次接收到一条写命令，就会写入日志文件中，当然是先写入os cache的，然后每隔一定时间再fsync一下
- 而且即使AOF和RDB都开启了，redis重启的时候，也是优先通过AOF进行数据恢复的，因为AOF数据比较完整
- 可以配置AOF的sync策略
  - always：每次写入一条数据，立即将这个数据对应的写日志fsync到磁盘上去，性能非常差，吞吐量很低，确保说redis里的数据一条都不丢。
  - everysec：每秒将os cache中的数据fsync到磁盘，这个最常用的，生产环境一般都这么配置，性能很高。
  - no：仅仅redis负责将数据写入os cache，持久化磁盘是由操作系统来决定的。

AOF常用配置：

appendonly no：是否开启AOF   
appendfilename “appendonly.aof”：AOF文件名 
dir ./：RDB文件和AOF文件所在目录  
appendfsync everysec：fsync持久化策略  
no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期  间的数据；需要在负载和安全性之间进行平衡   
auto-aof-rewrite-percentage 100：文件重写触发条件之一 执行AOF重写时，当前AOF大小(即aof_current_size)和上一次重写时AOF大小(aof_base_size)的比值。  
auto-aof-rewrite-min-size 64mb：文件重写触发提交之一 执行AOF重写时，文件的最小体积，默认值为64MB。  
aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件     

**(2)AOF rewrite**

redis中的数据其实有限的，很多数据可能会自动过期，可能会被用户删除，可能会被redis用缓存清除的算法清理掉。

redis中的数据会不断淘汰掉旧的，就一部分常用的数据会被自动保留在redis内存中，所以可能很多之前的已经被清理掉的数据，对应的写日志还停留在AOF中，AOF日志文件就一个，会不断的膨胀，到很大很大。所以AOF会自动在后台每隔一定时间做rewrite操作：比如日志里已经存放了针对100w数据的写日志了，redis内存只剩下10万；基于内存中当前的10万数据构建一套最新的日志到AOF中。

配置方式：redis.conf中可以配置rewrite策略：

auto-aof-rewrite-percentage 100 
auto-aof-rewrite-min-size 64mb

比如说，上一次AOF rewrite之后是128mb，然后就会接着128mb继续写AOF的日志，如果发现增长的比例超过了之前的100%，也就是达到了256mb，就可能会去触发一次rewrite，但是此时还要去跟min-size，64mb去比较，如果大小大于64mb，才会去触发rewrite。

AOF rewrite触发流程：

1. redis fork一个子进程
2. 子进程基于当前内存中的数据，构建日志，开始往一个新的临时的AOF文件中写入日志
3. redis主进程，接收到client新的写操作之后，在内存中写入日志，同时新的日志也继续写入旧的AOF文件
4. 子进程写完新的日志文件之后，redis主进程将内存中的新日志再次追加到新的AOF文件中
5. 用新的日志文件替换掉旧的日志文件。

**(3)AOF破损文件的修复**

如果redis在append数据到AOF文件时，机器宕机了，可能会导致AOF文件破损

用redis-check-aof --fix命令来修复破损的AOF文件

**(4)AOF和RDB同时工作**

1. 如果RDB在执行快照操作，那么redis不会执行AOF rewrite；如果redis再执行AOF rewrite，那么就不会执行RDB 快照
2. 如果RDB在执行快照，此时用户执行BGREWRITEAOF命令，那么等RDB快照生成之后，才会去执行AOF rewrite
3. 同时有RD快照和AOF日志文件，那么redis重启的时候，会优先使用AOF进行数据恢复，因为其中的日志更完整。

